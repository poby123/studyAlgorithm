/*
문제
수식은 일반적으로 3가지 표기법으로 표현할 수 있다. 연산자가 피연산자 가운데 위치하는 중위 표기법(일반적으로 우리가 쓰는 방법이다), 
연산자가 피연산자 앞에 위치하는 전위 표기법(prefix notation), 연산자가 피연산자 뒤에 위치하는 후위 표기법(postfix notation)이 그것이다. 
예를 들어 중위 표기법으로 표현된 a+b는 전위 표기법으로는 +ab이고, 후위 표기법으로는 ab+가 된다.

이 문제에서 우리가 다룰 표기법은 후위 표기법이다. 
후위 표기법은 위에서 말한 법과 같이 연산자가 피연산자 뒤에 위치하는 방법이다. 
이 방법의 장점은 다음과 같다. 
우리가 흔히 쓰는 중위 표기식 같은 경우에는 덧셈과 곱셈의 우선순위에 차이가 있어 왼쪽부터 차례로 계산할 수 없지만 후위 표기식을 사용하면 순서를 적절히 조절하여 순서를 정해줄 수 있다. 
또한 같은 방법으로 괄호 등도 필요 없게 된다. 예를 들어 a+b*c를 후위 표기식으로 바꾸면 abc*+가 된다.

중위 표기식을 후위 표기식으로 바꾸는 방법을 간단히 설명하면 이렇다. 
우선 주어진 중위 표기식을 연산자의 우선순위에 따라 괄호로 묶어준다. 
그런 다음에 괄호 안의 연산자를 괄호의 오른쪽으로 옮겨주면 된다.

예를 들어 a+b*c는 (a+(b*c))의 식과 같게 된다. 
그 다음에 안에 있는 괄호의 연산자 *를 괄호 밖으로 꺼내게 되면 (a+bc*)가 된다. 마지막으로 또 +를 괄호의 오른쪽으로 고치면 abc*+가 되게 된다.

이러한 사실을 알고 중위 표기식이 주어졌을 때 후위 표기식으로 고치는 프로그램을 작성하시오

입력
첫째 줄에 중위 표기식이 주어진다. 단 이 수식의 피연산자는 A~Z의 문자로 이루어지며 수식에서 한 번씩만 등장한다. 
그리고 -A+B와 같이 -가 가장 앞에 오거나 AB와 같이 *가 생략되는 등의 수식은 주어지지 않는다. 
표기식은 알파벳 대문자와 +, -, *, /, (, )로만 이루어져 있으며, 길이는 100을 넘지 않는다. 

출력
첫째 줄에 후위 표기식으로 바뀐 식을 출력하시오

예제 입력 1 
A*(B+C)
예제 출력 1 
ABC+*
*/

/*
    후위 표기 알고리즘 :
    1. 피연산자는 결과 문자열에 즉시 추가한다.
    2. 연산자의 경우, 스택에 현재 연산자보다 우선순위가 낮은 기호가 나올 때까지, 팝해서 결과 문자열에 추가한다.
        2-1. ( : 바로 스택에 넣는다.
        2-2. *, / 가 등장하는 경우, 스택에서 우선순위가 낮은 기호가 나올 때까지, 결과 문자열에 추가한다.
        2-3: +, - 가 등장하는 경우, 스택에서 ( 가 나올 때까지, 결과 문자열에 추가한다.
        2-4. ) : (가 나올 때까지 결과 문자열에 추가한다.
    3. 계산식을 모두 순회하고, 스택이 비어있지 않은 경우, 남아있는 연산자를 결과 문자열에 추가한다.
*/
#include <iostream>
#include <stack>
#include <cctype>
using namespace std;

stack<char> op;
string express, ans;

int main()
{
    cin.tie(0);
    ios::sync_with_stdio(0);

    cin >> express;

    for (int i = 0; i < express.size(); i++)
    {
        char cur = express[i];
        switch (cur)
        {
        case '(':
            // ( 는 바로 스택에 바로 넣는다.
            op.push(cur);
            break;

        case '*':
        case '/':
            // 자기보다 먼저 들어온 곱하기와 나누기 연산을 모두 꺼낸다.
            while (!op.empty() && (op.top() == '*' || op.top() == '/'))
            {
                ans += op.top();
                op.pop();
            }
            op.push(cur);
            break;
        
        case '+':
        case '-':
            // 자기보다 먼저 들어온 곱하기, 나누기, 더하기, 빼기 연산을 모두 꺼낸다.
            while (!op.empty() && (op.top() != '('))
            {
                ans += op.top();
                op.pop();
            }
            op.push(cur);
            break;
        
        case ')':
            // ( 를 만날 때까지 모두 꺼낸다. 마지막으로 ( 도 꺼낸다.
            while (!op.empty() && op.top() != '(')
            {
                ans += op.top();
                op.pop();
            }
            if (!op.empty())
            {
                op.pop();
            }
            break;

        default:
            // 피연산자는 바로 추가한다.
            ans += cur;
        }
    }

    // 식을 모두 순회하고 남은 연산을 모두 꺼내서, 결과 문자열에 추가한다.
    while (!op.empty())
    {
        ans += op.top();
        op.pop();
    }

    cout << ans;

    return 0;
}