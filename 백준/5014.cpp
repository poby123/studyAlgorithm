/*
문제
강호는 코딩 교육을 하는 스타트업 스타트링크에 지원했다. 오늘은 강호의 면접날이다. 하지만, 늦잠을 잔 강호는 스타트링크가 있는 건물에 늦게 도착하고 말았다.

스타트링크는 총 F층으로 이루어진 고층 건물에 사무실이 있고, 스타트링크가 있는 곳의 위치는 G층이다. 강호가 지금 있는 곳은 S층이고, 이제 엘리베이터를 타고 G층으로 이동하려고 한다.

보통 엘리베이터에는 어떤 층으로 이동할 수 있는 버튼이 있지만, 강호가 탄 엘리베이터는 버튼이 2개밖에 없다. 
U버튼은 위로 U층을 가는 버튼, D버튼은 아래로 D층을 가는 버튼이다. (만약, U층 위, 또는 D층 아래에 해당하는 층이 없을 때는, 엘리베이터는 움직이지 않는다)

강호가 G층에 도착하려면, 버튼을 적어도 몇 번 눌러야 하는지 구하는 프로그램을 작성하시오. 만약, 엘리베이터를 이용해서 G층에 갈 수 없다면, "use the stairs"를 출력한다.

입력
첫째 줄에 F, S, G, U, D가 주어진다. (1 ≤ S, G ≤ F ≤ 1000000, 0 ≤ U, D ≤ 1000000) 건물은 1층부터 시작하고, 가장 높은 층은 F층이다.

출력
첫째 줄에 강호가 S층에서 G층으로 가기 위해 눌러야 하는 버튼의 수의 최솟값을 출력한다. 만약, 엘리베이터로 이동할 수 없을 때는 "use the stairs"를 출력한다.

예제 입력 1 
10 1 10 2 1
예제 출력 1 
6
예제 입력 2 
100 2 1 1 0
예제 출력 2 
use the stairs
*/

/*
    1. 그리디 알고리즘이 아닌 이유. 다음 예제를 보자.

    건물 층(F) : 99층
    현재 위치(S) : 50층 
    U : 50
    D : 1
    목표 위치(G) : 99층

    만약 (현재 위치 - 목표 위치)의 "부호"에 따라 올라가야할지, 내려가야할 지 결정한다면
    먼저 D 버튼을 눌러야함에도 불구하고, U 버튼을 누를 것이고
    50(S) + 50(U) = 100 > 99(F) 이므로 "use the stairs"가 출력될 것이다.
    
    이 문제는 U 버튼을 누를지, D 버튼을 누를지 "순서"를 고려해야하며, 따라서 현재 층에 대해 내려가고 올라가는 경우를 모두 고려해야한다. 
    따라서 그리디 알고리즘으로 풀면 안되고, 최단 경로를 찾는 문제이므로 BFS로 풀어야한다.

    2. DFS가 아닌 이유.
    DFS로 하게 되면 처음 방문했을 때보다, 나중에 방문한 경우가 더 짧은 경우가 생길 수 있는데, 이런 경우를 모두 중복해서 탐색하면
    시간복잡도가 지수가 되기 때문에 너무 느리다.
*/

#include <iostream>
#include <queue>
using namespace std;

int F, G, S, U, D, cost[1000001];

int bfs()
{
    queue<int> q;
    q.push(S);
    cost[S] = 1;

    while (!q.empty())
    {
        int cur = q.front();
        q.pop();
        int cur_cost = cost[cur];
        int up = cur + U;
        int down = cur - D;

        if (cur == G)
        {
            return cur_cost - 1;
        }
        if (up <= F && !cost[up])
        {
            cost[up] = cur_cost + 1;
            q.push(up);
        }
        if (down >= 1 && !cost[down])
        {
            cost[down] = cur_cost + 1;
            q.push(down);
        }
    }
    return -1;
}

int main()
{

    cin.tie(0);
    ios::sync_with_stdio(0);

    cin >> F >> S >> G >> U >> D;

    int ans = bfs();
    if (ans >= 0)
    {
        cout << ans;
    }
    else
    {
        cout << "use the stairs";
    }

    return 0;
}